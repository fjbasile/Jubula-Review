\documentclass{article}

\usepackage{fancyhdr}

\pagestyle{fancy}

\lhead{Group 12}
\rhead{Software Testing Tools Report - Jubula}

\begin{document}

Jubula, written by BREDEX GmbH, is a free software testing tool that can run independently as a standalone utility, or perhaps more popularly, as an add-on to the Eclipse IDE downloaded through the Eclipse Marketplace. While our chief language focus was its usability with Java, Jubula supports full integration testing with Swing, SWT/RCP/GEF, JavaFX, HTML, and iOS applications. Independently, or via the IDE, it is runnable on Windows, Linux, and MacOS. Jubula's chief claim to fame is that it ``provides automated functional GUI testing for various types of application. It is aimed at teams who want their automated tests to be written by test experts from the user perspective, without requiring any coding effort." The truth, on the other hand, is a bit more complicated than that. \\

Primarily used during the functional testing phase, perhapse the best way to describe Jubula is that it performs GUI testing in an automated manner. This includes text field entries, button clicks, and other complex graphical interactions such as mouse scrolling. Configuring and using Jubula, however, isn't as simple as it sounds. The first order of business is to tell Jubula which Activity Under Test (AUT) you'd like to use. Once an AUT has been pointed to, the next step is to build a test case.\\

One of the strengths of Jubula is how test cases can be configured using a ``Keyword Approach." That is, words like ``Left Click Button" and ``Replace Text" connect arbitrary identifiers with a ``meaningful name" to the AUT. Once those actions and their properties are defined, each test case can be added to a test suite. Finally, that test suite can be run in what is called Object-Mapping Mode (OMP). OMP, though incredibly simple in hindsight, seems like the most overwhelming and non-intuitive portion of using Jubula. This is largely because it is this stage of the process that one has to link each previously described action to a certain part of the AUT. For example, with the Plotter program, once the program is run, you have to select the object (``Draw" button, ``Function" field, etc...) and link it to your previously defined activity. Once all appropriate actions are mapped with their corresponding objects, the test can finally be run. \\

When the first test actually runs successfully, you get a taste of both a great sense of pride in having figured it out, as well as an awestruck reality as to how powerful Jubula can be. All of this work that went into figuring out how to run the test coalesces into the reality that you can force Jubula to put in numerous amounts of text inputs, click buttons all day long if needed, and perform results checking of your GUI enmasse. For all the pain and frustration as the initial startup cost, Jubula pays itself off in a rewarding way as it clicks through your GUI program with ease, and reports on what it could and couldn't do. Overall, Jubula was fun to work with, and clearly powerful. However, due to its relatively steep initial learning curve, it is probably better suited for large scale GUI projects with an expansive UI. For smaller projects like that of the Plotter program, the time investment in learning all the subtle nuances of Jubula may be a bit too much. 
\end{document}
